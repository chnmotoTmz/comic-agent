# ADKコミックエージェントプロジェクト 技術・運用ルール

## 1. はじめに (Introduction)

このドキュメントは、Google Agent Development Kit (ADK) を使用したコミックエージェントプロジェクトにおける技術的および運用上のルールを定めるものです。これらのルールは、プロジェクト内での一貫性を保ち、コードの保守性を高め、チームメンバー間の円滑な共同作業を促進することを目的としています。

全員がこれらの指針に従うことで、開発プロセスの効率化、品質の向上、そしてより創造的な作業への集中が可能になります。

## 2. ファイル命名規則 (File Naming Conventions)

ファイル名は、その内容や目的を明確に示し、プロジェクト内での検索性や可読性を高めるために重要です。以下に、ファイルの種類ごとの命名規則を示します。

*   **Pythonファイル (Python Files)**:
    *   スネークケース (小文字、単語間をアンダースコア `_` で区切る) を使用します。
    *   例:
        *   `story_agent.py`
        *   `data_loader.py`
        *   `comic_utils.py`

*   **設定ファイル (Configuration Files)**:
    *   ファイルの内容を表す記述的な名前を付け、スネークケースまたはケバブケース (小文字、単語間をハイフン `-` で区切る) を使用します。拡張子は `.yaml` または `.json` とします。
    *   例:
        *   `config_agent_settings.yaml`
        *   `model_parameters.json`
        *   `database-credentials.yaml` (ケバブケースの例)
        *   `workflow_triggers.yaml`

*   **ワークフロー定義ファイル (Workflow Files)**:
    *   ワークフローの目的を明確に示す名前を付け、スネークケースを使用します。拡張子は `.json`、`.yaml`、またはADKがサポートする他の形式とします。
    *   例:
        *   `workflow_story_generation.json`
        *   `workflow_character_interaction.yaml`
        *   `plot_analysis_flow.yaml`

*   **ツール定義ファイル (Tool Definition Files)**:
    *   ツールの機能を具体的に示す名前を付け、スネークケースを使用します。Pythonでツールを定義する場合、ファイル名はPythonファイルの規則に従います。
    *   例:
        *   `tool_character_database.py`
        *   `image_analysis_tool.py`
        *   `prompt_enhancer_tool.py`

## 3. ツールとエージェントの命名規則 (Tool and Agent Naming Conventions)

コード内での命名は、その可読性と保守性に直接影響します。一貫した命名規則に従うことで、他の開発者がコードを理解しやすくなります。

*   **Pythonクラス名 (Agents, Tools, etc.)**:
    *   パスカルケース (単語の先頭を大文字にし、連結する) を使用します。
    *   エージェントクラスには `Agent`、ツールクラスには `Tool` を接尾辞として付けることを推奨します。
    *   例:
        *   `StoryGeneratorAgent`
        *   `CharacterDatabaseTool`
        *   `ImageAnalysisService` (ツールではないが、サービスを提供するクラスの例)
        *   `PlotOptimizerAgent`
        *   `DialogueGenerationTool`

*   **関数名・メソッド名 (Function and Method Names)**:
    *   スネークケース (小文字、単語間をアンダースコア `_` で区切る) を使用します。
    *   例:
        *   `def generate_story_idea(prompt: str) -> str:`
        *   `def get_character_details(character_id: int) -> dict:`
        *   `def _private_helper_function():` (内部使用のメソッド/関数はアンダースコアで始める)
        *   `def calculate_plot_complexity(plot_points: list) -> float:`

*   **変数名 (Variable Names)**:
    *   スネークケース (小文字、単語間をアンダースコア `_` で区切る) を使用します。
    *   例:
        *   `user_input = "..."`
        *   `generated_text_output = "..."`
        *   `max_retries = 3`
        *   `character_name_list = []`
        *   `current_scene_description = "..."`

*   **定数名 (Constant Names)**:
    *   大文字のスネークケース (大文字、単語間をアンダースコア `_` で区切る) を使用します。
    *   例:
        *   `MAX_OUTPUT_TOKENS = 2048`
        *   `DEFAULT_MODEL_NAME = "gemini-1.5-pro"`
        *   `API_REQUEST_TIMEOUT = 60`

## 4. モジュール構成の指針 (Module Structure Guidelines)

プロジェクトのディレクトリ構造は、`adk.md` ドキュメントで概説されているものを基本とします。各主要ディレクトリには、以下の指針に従ってコードやリソースを配置します。

*   **`/agents`**:
    *   エージェントのコアロジックを実装するPythonクラスを格納します。
    *   各エージェントは、特定の高レベルなタスク（例: ストーリー生成、キャラクター管理、読者との対話）を担当します。
    *   例: `InteractiveReaderAgent` クラスは `agents/interactive_reader_agent.py` に配置します。

*   **`/tools`**:
    *   エージェントが利用する再利用可能なツールやユーティリティの定義を格納します。
    *   これには、LLMとのインタフェース、データベースアクセス、外部API連携、特定のデータ処理関数（例: テキストからの感情分析、画像からの特徴抽出）などが含まれます。
    *   例: `SentimentAnalysisTool` クラスは `tools/sentiment_analysis_tool.py` に、コミック特有のユーティリティ関数群は `tools/comic_format_utils.py` に配置します。

*   **`/workflows`**:
    *   エージェントのタスクフローを定義する設定ファイル（JSON、YAMLなど）やPythonスクリプトを格納します。
    *   ワークフローは、複数のツールやエージェントのステップを組み合わせて、より複雑な処理の流れ（例: 原作者が入力したプロットに基づき、キャラクターを生成し、最初の3シーンのネーム案を出力する）を記述します。
    *   例: `workflow_new_character_arc_generation.yaml` は、新キャラクターのアーク生成から関連シーン提案までの流れを定義します。

*   **`/config`**:
    *   プロジェクト全体や各モジュール（エージェント、ツール）の設定ファイルを格納します。
    *   APIキー、モデルパラメータ、データベース接続情報、エージェントのデフォルト設定、ワークフローのトリガー条件などが含まれます。
    *   例: `global_settings.yaml`, `llm_provider_settings.json`, `.env` (環境変数用、`.gitignore` に追加)。

*   **`/stories`**:
    *   原作データ、生成されたストーリーコンテンツ、キャラクターシート、プロット概要、世界観設定資料など、コミック制作に関連するデータを保存します。
    *   フォーマットはテキストファイル、Markdown、JSON、XML、画像ファイルなど、内容に応じて適切なものを選択します。
    *   サブディレクトリを作成してジャンル別やキャラクター別に整理することも推奨されます (例: `/stories/fantasy_world_1/characters/`)。

*   **`/tests`**:
    *   ユニットテスト (`unittest`, `pytest`) や統合テストのコードを格納します。
    *   エージェント、ツール、ワークフローの各コンポーネントが期待通りに動作することを保証するためのテストを記述します。
    *   テストデータやモックオブジェクトもこのディレクトリ内に配置することがあります。
    *   例: `tests/agents/test_story_agent.py`, `tests/tools/test_image_analysis_tool.py`。

## 5. プロンプトエンジニアリングのベストプラクティス (Prompt Engineering Best Practices)

大規模言語モデル（LLM）から期待される出力を得るためには、プロンプトの設計が非常に重要です。以下に、効果的なプロンプトを作成するためのベストプラクティスを示します。

*   **明確性と具体性 (Clarity and Specificity)**:
    *   LLMに対する指示は、曖昧さを排し、具体的で明確に記述します。何を、どのような形式で、どの程度の詳細さで出力してほしいのかを正確に伝えます。
    *   改善が必要な例: 「コミックのシーンを考えて。」
    *   良い例: 「高校の化学実験室を舞台にした、2ページ分のコミックシーンのネームを作成してください。登場人物は内気な男子生徒Aと活発な女子生徒Bです。Aが実験に失敗し、小さな爆発が起こり、Bがそれをからかう、というコメディタッチの展開でお願いします。各コマの構図と主要なセリフを記述してください。」

*   **文脈情報 (Contextual Information)**:
    *   LLMがタスクを理解し、より適切な応答を生成するために必要な背景情報や文脈を提供します。これには、物語のジャンル、既存のプロット、キャラクターの性格や関係性、世界のルールなどが含まれます。
    *   例: 新しいシーンのアイデアを生成させる場合、「現在の物語の舞台は中世ファンタジーで、主人公は魔法使いの弟子です。彼は師匠から重要な巻物を盗み出し、追われています。次のシーンで、彼が森の中で偶然見つけた古い遺跡に隠れる展開を考えてください。」のように、状況を詳しく説明します。

*   **ロールプレイング (Role Playing)**:
    *   LLMに特定の役割（ペルソナ）を与えることで、その役割になりきったトーンやスタイルの出力を促します。
    *   例: 「あなたはベテランのコミック原作者です。読者がハラハラするような、サスペンスフルな次回予告のナレーションを3パターン考えてください。」
    *   例: 「あなたはキャラクターデザイナーです。内向的だが芯の強い10代の少女のキャラクターデザイン案について、服装、髪型、特徴的なアクセサリーのアイデアを説明してください。」

*   **反復的な改善 (Iterative Refinement)**:
    *   最初のプロンプトで完璧な結果が得られることは稀です。生成された出力を評価し、プロンプトを少しずつ修正・改善していく反復的なプロセスが不可欠です。
    *   異なる言い回し、指示の追加・削除、構造の変更、LLMの温度設定（temperature）などのパラメータ調整を試します。A/Bテストのように複数のプロンプトバリエーションを試すのも有効です。

*   **指示と出力形式の指定 (Instructional Prompts & Desired Output Formats)**:
    *   タスクのステップを明確に指示したり、出力の形式（例: JSON、リスト、特定のマークダウン構造、箇条書き）を指定したりすることで、LLMはより構造化された、利用しやすい形式で応答を返すことができます。
    *   例: 「以下のキャラクター情報を基に、彼の強みと弱みをそれぞれ3つずつ、箇条書きで挙げてください。\n情報：[キャラクター情報]\n\n強み:\n-\n-\n-\n\n弱み:\n-\n-\n-」
    *   例: 「シーンのアイデアをJSONオブジェクトのリストとして生成してください。各オブジェクトは 'scene_title', 'summary', 'key_elements' のキーを持つこと。」

*   **フューショット例 (Few-shot Examples)**:
    *   プロンプト内に、期待する入力と出力のペアの例をいくつか含める（フューショットプロンプティング）ことで、LLMはタスクのパターンを学習し、より正確な応答を生成しやすくなります。これは特に、複雑な指示や独自のフォーマットが必要な場合に有効です。
    *   例 (コミックのコマ説明生成の例):
        ```
        入力: 主人公が驚いて窓の外を見る。
        出力: 【コマ1】主人公の顔のアップ。目は大きく見開かれ、驚きの表情。背景には窓枠が少し見える。セリフ「まさか…！」

        入力: 敵が剣を振り下ろす。
        出力: 【コマ2】俯瞰に近いアングル。敵が力強く剣を振り下ろす瞬間。剣の軌跡にエフェクト線。主人公はかろうじて避けている。効果音「ブンッ！」

        入力: 夕焼け空の下、二人が黙って歩いている。
        出力:
        ```
        (LLMが同様の形式でコマ説明を補完することを期待)

## 6. Git運用ルール (Git Workflow Recommendations)

バージョン管理システムGitの適切な運用は、チーム開発の効率とコード品質を維持するために不可欠です。以下のルールを推奨します。

*   **ブランチ戦略 (Branching Strategy)**:
    *   **`main`ブランチ (または `master`)**: 常にリリース可能な安定した状態を保ちます。直接コミットは行わず、プルリクエスト経由でのみマージします。CI/CDのトリガーとなることが多いです。
    *   **`develop`ブランチ**: 次期リリースのための開発のベースとなるブランチ。`main` から作成し、機能開発が一段落し、ある程度安定したら `main` にマージ（リリース準備のため）。日常的な開発の統合ポイントです。
    *   **フィーチャーブランチ (Feature Branches)**: 新機能の開発や特定のタスクごとに作成します。`develop` から分岐し、作業完了後に `develop` へプルリクエストを作成します。
        *   命名規則: `feature/brief-description` (例: `feature/new-story-arc-generator`), `task/update-char-schema`
    *   **バグ修正ブランチ (Bugfix Branches)**: バグ修正のために作成します。リリース済みのバグであれば `main` から、開発中のバグであれば `develop` から分岐し、修正後にそれぞれへプルリクエストを作成します。
        *   命名規則: `fix/bug-description` (例: `fix/error-in-prompt-parser`), `hotfix/critical-security-issue` (緊急性の高いmainブランチへの直接修正の場合)
    *   **リリースブランチ (Release Branches)**: リリース準備のために `develop` から分岐します（例: `release/v1.2.0`）。このブランチでは、リリースに向けた最終調整、軽微なバグ修正、ドキュメント更新などを行います。安定したら `main` と `develop` の両方にマージします。

*   **コミットメッセージ規約 (Commit Message Conventions)**:
    *   明確で簡潔なメッセージを記述します。変更内容とその理由がわかるようにします。
    *   [Conventional Commits](https://www.conventionalcommits.org/ja/v1.0.0/) の形式を強く推奨します。これにより、変更履歴の可読性が向上し、CHANGELOGの自動生成なども可能になります。
        *   フォーマット: `<type>(<scope>): <description>`
        *   `<type>` の例: `feat` (新機能), `fix` (バグ修正), `docs` (ドキュメント), `style` (コードスタイル), `refactor` (リファクタリング), `test` (テスト追加・修正), `chore` (ビルドプロセスや補助ツールの変更)
        *   `<scope>` (任意): 変更範囲を示す (例: `agent`, `tool-llm`, `config`)
        *   例:
            *   `feat(agent): Add dialogue generation capability to StoryAgent`
            *   `fix(tool-parser): Correct parsing error for multi-line character descriptions`
            *   `docs(rule): Update Git workflow section with release branch details`
            *   `style(agent): Apply Black formatting to story_agent.py`
            *   `refactor(tool-db): Optimize database query for character retrieval`
            *   `test(workflow): Add integration test for story generation workflow`
            *   `chore: Update .gitignore to exclude local .env files`
    *   コミットは論理的な単位（1つの関心事）で行い、関連のない変更を混ぜないようにします。

*   **プルリクエスト (PR) / マージリクエスト (MR) プロセス**:
    *   フィーチャーブランチやバグ修正ブランチから `develop` または `main` ブランチへのマージは、必ずプルリクエスト（またはマージリクエスト）を通じて行います。
    *   **セルフレビュー**: PRを作成する前に、開発者自身が変更内容を再確認します。
    *   **コードレビュー**: 最低1人（可能であれば2人以上）の他の開発者によるレビューを必須とします。レビューでは、コードの品質、規約の遵守、ロジックの妥当性、テストの網羅性、パフォーマンスへの影響などを確認します。
    *   **テスト**: プルリクエストに関連するユニットテストや統合テストが全て成功していることを必須条件とします。CI (Continuous Integration) ツールを導入し、これらのテストを自動実行することを強く推奨します。
    *   **マージ**: レビューでの指摘事項が修正され、テストが成功し、レビュワーから承認 (Approve) を得た後に、PRの作成者がマージ（またはリポジトリ管理者がマージ）します。Squash and Merge や Rebase and Merge など、プロジェクトで合意したマージ戦略に従います。

*   **メインブランチ保護 (Main Branch Protection)**:
    *   `main` ブランチ (および `develop` ブランチ) への直接プッシュを禁止し、プルリクエスト経由でのみ変更を許可するようにリポジトリ設定で保護ルールを適用します。
    *   ステータスチェック（CIテストの成功など）をマージの必須条件とすることも推奨されます。
    *   これにより、誤った変更や未レビューのコードが主要ブランチに混入するのを防ぎ、ブランチの安定性を高めます。

これらのルールはプロジェクトの状況に応じて調整されるべきですが、基本的な指針として機能することを意図しています。

---

## 7. AIエージェントとキャラクターの振る舞いルール (AI Agent and Character Behavior Rules)

これまでの技術的・運用上のルールに加え、本セクションではコミックエージェント、特に物語内のキャラクターとして振る舞うAIや、読者と対話するAIの創造的な側面とインタラクションスタイルに関する指針を定めます。これらのルールは、物語の一貫性を保ち、キャラクターの魅力を高め、読者に快適な体験を提供するために重要です。

### 7.1. キャラクターの性格と話し方の定義 (Defining Character Personalities and Speaking Styles)

物語に登場するキャラクター（AIがその役割を担う場合も含む）が一貫した振る舞いを見せることは、読者の没入感を高める上で非常に重要です。

*   **性格特性の定義の重要性**:
    *   キャラクターの行動や意思決定、感情表現の基盤となります。
    *   定義された性格は、プロンプトやエージェントの設定を通じてLLMに指示され、キャラクター描写の一貫性を保つのに役立ちます。

*   **定義方法**:
    *   **キーワード**: キャラクターの核心的な性格をいくつかのキーワードで表現します。
        *   例: 「キャラクターA：勇敢、短気、友情に厚い、正義感が強い」
    *   **詳細な説明**: キャラクターの背景、価値観、動機、他人との接し方などを文章で記述します。
        *   例: 「キャラクターBは、過去のトラウマから人間不信に陥っているが、心の奥底では信頼できる仲間を求めている。普段は冷静沈着を装っているが、特定の話題になると感情的になることがある。」
    *   **キャラクターシートとの連携**: 詳細なキャラクターシート（`adk.md` の「キャラクター設定の管理」で言及）を作成し、その情報を参照するようにエージェントを設定します。

*   **話し方の定義**:
    *   キャラクターの性格や背景を反映した独自の話し方を定義します。これには、語彙の選択、口調、文末表現、一人称・二人称の使い方、特定のフレーズの頻用などが含まれます。
    *   例1: 「キャラクターA（勇敢、短気）：話し方：直接的でややぶっきらぼう。一人称は「俺」、二人称は「お前」または呼び捨て。仲間には時折、不器用な優しさを見せる言葉も使う。『ったく、しょうがねえな！』が口癖。」
    *   例2: 「キャラクターB（常に敬語を使う皮肉屋）：話し方：常に丁寧語（ですます調）を使うが、内容は辛辣で皮肉っぽいことが多い。知的な単語や比喩を好む。相手のことは「〇〇さん」と呼ぶ。『おやおや、それは大変興味深いご意見ですねぇ。』」
    *   例3: 「キャラクターC（明るく元気な若者）：話し方：くだけた言葉遣いで、流行語や感嘆符を多用する。感情表現が豊か。『マジで！？やったー！超ウケるんですけどー！』」

*   **プロンプト/設定への活用**:
    *   これらの定義は、LLMに対するプロンプト指示に直接組み込むか、エージェントの設定ファイルを通じてキャラクターごとの「ペルソナ」や「話し方テンプレート」として読み込ませることを想定しています。
    *   例 (プロンプト指示): 「以下のキャラクター設定に基づき、この危機的状況で彼が言いそうなセリフを3つ生成してください。\nキャラクター：キャラクターA（勇敢、短気、直接的な話し方）\n状況：仲間が敵に捕らえられた。」

### 7.2. 対話の制限と安全性のガイドライン (Dialogue Restrictions and Safety Guidelines)

AIエージェント、特に読者と直接対話する可能性のあるキャラクターやナビゲーターは、安全かつ倫理的なコミュニケーションを遵守する必要があります。

*   **禁止されるトピックと言語**:
    *   ヘイトスピーチ、差別的な発言、個人攻撃。
    *   露骨な性的コンテンツ、過度に暴力的な描写（物語の文脈上必要な場合でも、直接的な対話では慎重に扱う）。
    *   誤情報や偽情報の拡散（特に現実世界の事象に関するもの）。
    *   著作権を侵害する内容、プライバシーを侵害する情報。
    *   違法行為を助長する内容。

*   **デリケートなユーザー入力への対応**:
    *   ユーザーが不適切なトピックに言及したり、攻撃的な言葉を使ったりした場合、エージェントは冷静かつ丁寧に対応する必要があります。
    *   **無視/話題転換**: 軽微な場合や、意図せず不適切な言葉が出た場合は、その部分には触れずに話題を転換する。
        *   例: 「申し訳ありませんが、その話題についてはお答えできません。別のことについてお話ししませんか？例えば、この物語の次の展開について何かご希望はありますか？」
    *   **明確な拒否と終了**: 悪質な場合や、繰り返し不適切な行動が見られる場合は、対話を明確に拒否し、必要であれば丁寧に対話を終了する。
        *   例: 「申し訳ありませんが、そのような言葉遣いや内容の対話は継続できません。ご理解ください。」

*   **対象年齢への配慮**:
    *   コミック作品が特定の年齢層を対象としている場合、エージェントの言葉遣いや対話内容もその対象年齢にふさわしいものになるよう調整します。
    *   子供向けの作品であれば、より平易な言葉を選び、複雑な概念や成人向けのユーモアは避けます。

*   **エージェントの行動規範例**:
    *   「ルール1：常に礼儀正しく、敬意を持ってユーザーに接する。」
    *   「ルール2：不適切な言葉や暴力的な表現は、物語の引用など、文脈上必要な場合を除き避ける。ユーザーが不快感を示す場合は、話題を転換するか、丁寧に対応を終了する。」
    *   「ルール3：個人情報や機密情報を要求したり、保存したりしない。」
    *   「ルール4：エージェントはAIであり、人間ではないことを明確に（必要に応じて）伝える。」

### 7.3. ストーリーフローとエージェント応答の制御 (Controlling Story Flow and Agent Responses)

インタラクティブな要素を持つコミックエージェントでは、物語の進行やエージェントの応答を、特定のルールや条件に基づいて制御することが重要です。

*   **物語分岐のルール**:
    *   読者の選択や行動、あるいは特定のフラグ（条件）に基づいて、物語の展開を分岐させるルールを定義します。
    *   例 (ワークフロー定義や設定ファイルで記述):
        *   `if user_chooses_option_A and character_X_is_alive:`
            `  go_to_story_branch_Alpha_1`
        *   `else if user_chooses_option_B and has_item_Key:`
            `  go_to_story_branch_Beta_3`
        *   `else:`
            `  go_to_default_branch_Gamma_1`

*   **文脈に応じた条件付き応答**:
    *   エージェント（特にキャラクターAIやナビゲーターAI）の応答は、現在の物語の文脈、読者の過去の行動、特定のキーワードなどに基づいて変化するようにします。
    *   例: 「条件：読者がキャラクターAの過去について質問した場合、かつ物語の進行度がチャプター5未満の場合、事前に定義された短い要約（ネタバレなし）を提示する。チャプター5以上の場合、より詳細な情報（ただし核心的なネタバレは避ける）を提示する。」
    *   例: 「条件：読者が『助けて』というキーワードを発言し、かつ現在のシーンが戦闘シーンである場合、キャラクターAIは『今助けに行く！持ちこたえろ！』のような緊迫感のある応答をする。」

*   **物語の一貫性の維持**:
    *   エージェントは、確立されたプロットポイント、キャラクター設定、世界のルールと矛盾する情報を生成したり、行動をとったりしないように制御されるべきです。
    *   **知識ベースの参照**: エージェントは、物語の重要な情報を格納した知識ベース（例: キャラクターデータベース、世界観設定集）を参照し、その内容に準拠した応答を生成します。
    *   **矛盾チェック**: 高度な実装では、エージェントの生成する内容が既存の物語設定と矛盾しないかをチェックするメカニズムを導入することも考えられます（例: 新しい出来事が過去の出来事と時間的に矛盾しないか）。

*   **エージェントの記憶と状態管理**:
    *   長期的なインタラクションや、物語を通じたキャラクターの成長・変化を表現するためには、エージェントが過去の対話や出来事を記憶し、状態を管理する能力が必要です。
    *   **対話履歴の利用**: 短期的な文脈理解のために、直近の対話履歴をLLMのプロンプトに含めます。
    *   **状態変数の更新**: 物語の進行や読者の選択に応じて、エージェント内部の状態変数（例: `character_A_trust_level`, `plot_flag_X_triggered`）を更新し、それに基づいて応答や行動を変化させます。
    *   例: 「読者がキャラクターAに何度も親切な選択をした場合、`character_A_trust_level` が上昇し、キャラクターAのAIはより友好的な口調で話すようになる。」

これらの振る舞いルールは、エージェントがより魅力的で、信頼でき、物語の世界観に没入させる存在となるために不可欠です。プロジェクトの初期段階でこれらのルールを定義し、物語の発展やエージェントの進化に合わせて継続的に見直していくことが推奨されます。
